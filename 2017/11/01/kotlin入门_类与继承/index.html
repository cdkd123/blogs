<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>类与继承 | cdkd123&#39;s notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="类Kotlin 中使用关键字 class 声明类 12class Invoice &amp;#123;&amp;#125; 类声明由类名、类头（指定其类型参数、主构造函数等）和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。 1class Empty 构造函数在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和可选的类">
<meta name="keywords" content="kotlin,类与继承">
<meta property="og:type" content="article">
<meta property="og:title" content="类与继承">
<meta property="og:url" content="http://yoursite.com/2017/11/01/kotlin入门_类与继承/index.html">
<meta property="og:site_name" content="cdkd123&#39;s notes">
<meta property="og:description" content="类Kotlin 中使用关键字 class 声明类 12class Invoice &amp;#123;&amp;#125; 类声明由类名、类头（指定其类型参数、主构造函数等）和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。 1class Empty 构造函数在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和可选的类">
<meta property="og:updated_time" content="2018-03-10T08:07:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="类与继承">
<meta name="twitter:description" content="类Kotlin 中使用关键字 class 声明类 12class Invoice &amp;#123;&amp;#125; 类声明由类名、类头（指定其类型参数、主构造函数等）和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。 1class Empty 构造函数在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和可选的类">
  
    <link rel="alternate" href="/blogs/atom.xml" title="cdkd123&#39;s notes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blogs/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blogs/" id="logo">cdkd123&#39;s notes</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blogs/" id="subtitle">一个写写画画的地方</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blogs/">Home</a>
        
          <a class="main-nav-link" href="/blogs/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blogs/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-kotlin入门_类与继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/01/kotlin入门_类与继承/" class="article-date">
  <time datetime="2017-11-01T09:16:36.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blogs/categories/kotlin/">kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      类与继承
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Kotlin 中使用关键字 class 声明类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Invoice &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类声明由<em>类名、类头（指定其类型参数、主构造函数等）和由大括号包围的类体</em>构成。<br>类头和类体都是<em>可选</em>的； 如果一个类没有类体，可以省略花括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Empty</span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在 Kotlin 中的一个类可以有一个<em>主构造函数</em>和<em>一个或多个次构造函数</em>。主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(firstName: String) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Person(firstName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>主构造函数不能包含任何的代码</strong>。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Customer(name: String) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">    		name = 3</span><br><span class="line">        logger.info(&quot;Customer initialized with value $&#123;name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<strong>主构造的参数可以在初始化块中使用</strong>。它们也可以在类体内声明的属性初始化器中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Customer(name: String) &#123;</span><br><span class="line">    val customerKey = name.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(val firstName: String, val lastName: String, var age: Int) &#123;</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。<br>如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Customer public @Inject constructor(name: String) &#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>更多详情，参见 <a href="https://www.kotlincn.net/docs/reference/visibility-modifiers.html#构造函数" target="_blank" rel="noopener">可见性修饰符</a></p>
<h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>类也可以声明前缀有 constructor的次构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(parent: Person) &#123;</span><br><span class="line">        parent.children.add(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(val name: String) &#123;</span><br><span class="line">    constructor(name: String, gender: Boolean) : this(name) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    constructor(name: String, age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class DontCreateMe private constructor () &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Customer(val customerName: String = &quot;&quot;)</span><br></pre></td></tr></table></figure>
<p>创建类的实例<br>要创建一个类的实例，我们就像普通函数一样调用构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val invoice = Invoice()</span><br><span class="line"></span><br><span class="line">val customer = Customer(&quot;Joe Smith&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>注意 Kotlin 并没有 new 关键字。</strong></p>
<p>创建嵌套类、内部类和匿名内部类的类实例在嵌套类中有述。<br>类成员<br>类可以包含：<br>        构造函数和初始化块<br>        函数<br>        属性<br>        嵌套类和内部类<br>        对象声明</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 Kotlin 中所有类都有一个共同的超类 <strong>Any</strong>，这对于没有超类型声明的类是默认超类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Example // 从 Any 隐式继承</span><br></pre></td></tr></table></figure>
<p>Any 不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。 更多细节请查阅Java互操作性部分。<br>要声明一个显式的超类型，我们把类型放到类头的冒号之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open class Base(p: Int) `</span><br><span class="line">class Derived(p: Int) : Base(p)</span><br></pre></td></tr></table></figure>
<p>如果该类有一个主构造函数，其基类型可以（并且必须） 用（基类型的）主构造函数参数就地初始化。<br>如果类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyView : View &#123;</span><br><span class="line">    constructor(ctx: Context) : super(ctx)</span><br><span class="line"></span><br><span class="line">    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类上的 open 标注与 Java 中 final 相反，它允许其他类从这个类继承。<br><strong>默认情况下，在 Kotlin 中所有的类都是 final</strong>， 对应于 Effective Java书中的第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承。</p>
<h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>我们之前提到过，Kotlin 力求清晰显式。与 Java 不同，Kotlin 需要显式标注可覆盖的成员（我们称之为开放）和覆盖后的成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class Base &#123;</span><br><span class="line">    open fun v() &#123;&#125;</span><br><span class="line">    fun nv() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived() : Base() &#123;</span><br><span class="line">    override fun v() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Derived.v() 函数上必须加上 override标注。如果没写，编译器将会报错。 如果函数没有标注 open 如 Base.nv()，则子类中不允许定义相同签名的函数， 不论加不加 override。在一个 final 类中（没有用 open 标注的类），开放成员是禁止的。<br>标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class AnotherDerived() : Base() &#123;</span><br><span class="line">    final override fun v() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h2><p>属性覆盖与方法覆盖类似；<strong>在超类中声明然后在派生类中重新声明的属性必须以 override 开头，并且它们必须具有兼容的类型。每个声明的属性可以由具有初始化器的属性或者具有 getter 方法的属性覆盖。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class Foo &#123;</span><br><span class="line">    open val x: Int get() &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar1 : Foo() &#123;</span><br><span class="line">    override val x: Int = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。 </p>
<p>请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">    val count: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar1(override val count: Int) : Foo</span><br><span class="line"></span><br><span class="line">class Bar2 : Foo &#123;</span><br><span class="line">    override var count: Int = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用超类实现"><a href="#调用超类实现" class="headerlink" title="调用超类实现"></a>调用超类实现</h2><p>派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">open class Foo &#123;</span><br><span class="line">    open fun f() &#123; println(&quot;Foo.f()&quot;) &#125;</span><br><span class="line">    open val x: Int get() = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar : Foo() &#123;</span><br><span class="line">    override fun f() &#123; </span><br><span class="line">        super.f()</span><br><span class="line">        println(&quot;Bar.f()&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override val x: Int get() = super.x + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实现：super@Outer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Bar : Foo() &#123;</span><br><span class="line">    override fun f() &#123; /* …… */ &#125;</span><br><span class="line">    override val x: Int get() = 0</span><br><span class="line">    </span><br><span class="line">    inner class Baz &#123;</span><br><span class="line">        fun g() &#123;</span><br><span class="line">            super@Bar.f() // 调用 Foo 实现的 f()</span><br><span class="line">            println(super@Bar.x) // 使用 Foo 实现的 x 的 getter</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h2><p>在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super<base>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;</span><br><span class="line">    fun f() &#123; print(&quot;A&quot;) &#125;</span><br><span class="line">    fun a() &#123; print(&quot;a&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B &#123;</span><br><span class="line">    fun f() &#123; print(&quot;B&quot;) &#125; // 接口成员默认就是“open”的</span><br><span class="line">    fun b() &#123; print(&quot;b&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C() : A(), B &#123;</span><br><span class="line">    // 编译器要求覆盖 f()：</span><br><span class="line">    override fun f() &#123;</span><br><span class="line">        </span><br><span class="line">        super&lt;A&gt;.f() // 调用 A.f()</span><br><span class="line">        super&lt;B&gt;.f() // 调用 B.f()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时继承 A 和 B 没问题，并且 a() 和 b() 也没问题因为 C 只继承了每个函数的一个实现。 但是 f() 由 C继承了两个实现，所以我们必须在 C 中覆盖 f() 并且提供我们自己的实现来消除歧义。<br>抽象类<br>类和其中的某些成员可以声明为 abstract。 抽象成员在本类中可以不用实现。 <strong>需要注意的是，我们并不需要用 open 标注一个抽象类或者函数</strong>——因为这不言而喻。<br>我们可以用一个抽象成员覆盖一个非抽象的开放成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class Base &#123;</span><br><span class="line">    open fun f() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Derived : Base() &#123;</span><br><span class="line">    override abstract fun f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伴生对象-–-java中的静态类"><a href="#伴生对象-–-java中的静态类" class="headerlink" title="伴生对象 – (java中的静态类)"></a>伴生对象 – (java中的静态类)</h2><p>与 Java 或 C# 不同，在 Kotlin 中类没有静态方法。在大多数情况下，它建议简单地使用包级函数。<br>如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。<br>更具体地讲，如果在你的类内声明了一个伴生对象， 你就可以使用像在 Java/C# 中调用静态方法相同的语法来调用其成员，只使用类名作为限定符。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    fun bark()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Food&#123;</span><br><span class="line">    fun eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Delegate(animal: Animal, food: Food) : Animal by animal, Food by food &#123;</span><br><span class="line">    override fun eat() &#123;</span><br><span class="line">        println(&quot;mouse&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun bark() &#123;</span><br><span class="line">        println(&quot;Miao&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伪多继承的实现-–-接口的代理实现"><a href="#伪多继承的实现-–-接口的代理实现" class="headerlink" title="伪多继承的实现 – 接口的代理实现"></a>伪多继承的实现 – 接口的代理实现</h2><p>Kotlin的动态代理更多的是用在一种需要多继承的场景。<br>例如，还是之前我举的我朋友那个项目的例子，他们的问题在于，每个BaseActivity的子类，都会要请求不同的网络，可能A需要获取用户信息，B需要获取活动列表，C既需要活动列表也需要获取用户信息，D却只需要获取图片列表。</p>
<p>这样一个场景，使用一个代理类实现所有需要获取信息的接口方法。然后让不同的子类去实现所需的接口，请求统一交给代理类完成。这样不仅维护网络请求信息方便，而且每个类不会有额外多出来的方法防止新人接触项目的时候调用错请求方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    fun bark()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Food&#123;</span><br><span class="line">    fun eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Delegate : Animal, Food &#123;</span><br><span class="line">    override fun eat() &#123;</span><br><span class="line">        println(&quot;mouse&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun bark() &#123;</span><br><span class="line">        println(&quot;Miao&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat(animal: Animal, food: Food) : Animal by animal, Food by food &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@JvmStatic fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val delegate: Delegate = Delegate()</span><br><span class="line"></span><br><span class="line">    Cat(delegate, delegate).bark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/01/kotlin入门_类与继承/" data-id="cjl2cx9ri0010zxqez5aqumsv" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/类与继承/">类与继承</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blogs/2017/11/01/kotlin入门_属性和属性委托/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nuevo</strong>
      <div class="article-nav-title">
        
          kotlin入门-属性
        
      </div>
    </a>
  
  
    <a href="/blogs/2017/11/01/kotlin入门_抽象类和接口/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Viejo</strong>
      <div class="article-nav-title">kotlin入门_抽象类和接口</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorías</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blogs/categories/kotlin/">kotlin</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/DSL/">DSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/android架构/">android架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/c/">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/computer-science/">computer science</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/gitpages使用指南/">gitpages使用指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/java异常/">java异常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/kotlin-入门视频笔记-java和kotlin共存/">kotlin 入门视频笔记 java和kotlin共存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/kotlin资源/">kotlin资源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/lambda表达式/">lambda表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/tapout/">tapout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/unity3d/">unity3d</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/偏函数-partial-function/">偏函数 (partial function)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/健身/">健身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/动画状态机/">动画状态机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/反射/">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/复合函数/">复合函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/生活小事/">生活小事</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/类与继承/">类与继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/评论/">评论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/食物识别/">食物识别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/高阶函数/">高阶函数</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/blogs/tags/DSL/" style="font-size: 10px;">DSL</a> <a href="/blogs/tags/android架构/" style="font-size: 15px;">android架构</a> <a href="/blogs/tags/c/" style="font-size: 15px;">c++</a> <a href="/blogs/tags/computer-science/" style="font-size: 10px;">computer science</a> <a href="/blogs/tags/gitpages使用指南/" style="font-size: 10px;">gitpages使用指南</a> <a href="/blogs/tags/html/" style="font-size: 10px;">html</a> <a href="/blogs/tags/java异常/" style="font-size: 10px;">java异常</a> <a href="/blogs/tags/kotlin/" style="font-size: 20px;">kotlin</a> <a href="/blogs/tags/kotlin-入门视频笔记-java和kotlin共存/" style="font-size: 10px;">kotlin 入门视频笔记 java和kotlin共存</a> <a href="/blogs/tags/kotlin资源/" style="font-size: 10px;">kotlin资源</a> <a href="/blogs/tags/lambda表达式/" style="font-size: 10px;">lambda表达式</a> <a href="/blogs/tags/tapout/" style="font-size: 10px;">tapout</a> <a href="/blogs/tags/unity3d/" style="font-size: 10px;">unity3d</a> <a href="/blogs/tags/偏函数-partial-function/" style="font-size: 10px;">偏函数 (partial function)</a> <a href="/blogs/tags/健身/" style="font-size: 10px;">健身</a> <a href="/blogs/tags/动画状态机/" style="font-size: 10px;">动画状态机</a> <a href="/blogs/tags/反射/" style="font-size: 10px;">反射</a> <a href="/blogs/tags/复合函数/" style="font-size: 10px;">复合函数</a> <a href="/blogs/tags/生活小事/" style="font-size: 10px;">生活小事</a> <a href="/blogs/tags/类与继承/" style="font-size: 10px;">类与继承</a> <a href="/blogs/tags/评论/" style="font-size: 10px;">评论</a> <a href="/blogs/tags/食物识别/" style="font-size: 10px;">食物识别</a> <a href="/blogs/tags/高阶函数/" style="font-size: 10px;">高阶函数</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blogs/2018/08/19/听高老师讲架构2/">听高老师讲架构2-Messenger框架的妙用</a>
          </li>
        
          <li>
            <a href="/blogs/2018/08/19/听高老师讲架构1/">听高老师讲架构1</a>
          </li>
        
          <li>
            <a href="/blogs/2018/03/26/遗憾的婚礼见证人/">遗憾的婚礼见证人</a>
          </li>
        
          <li>
            <a href="/blogs/2018/03/01/电子货币投资记录/">(no title)</a>
          </li>
        
          <li>
            <a href="/blogs/2018/01/25/u3d动画状态机/">u3d动画状态机</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 tom<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blogs/" class="mobile-nav-link">Home</a>
  
    <a href="/blogs/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blogs/fancybox/jquery.fancybox.css">
  <script src="/blogs/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blogs/js/script.js"></script>



  </div>
</body>
</html>