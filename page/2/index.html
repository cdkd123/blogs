<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>cdkd123&#39;s notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="不定期更新">
<meta property="og:type" content="website">
<meta property="og:title" content="cdkd123&#39;s notes">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="cdkd123&#39;s notes">
<meta property="og:description" content="不定期更新">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cdkd123&#39;s notes">
<meta name="twitter:description" content="不定期更新">
  
    <link rel="alternate" href="/blogs/atom.xml" title="cdkd123&#39;s notes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blogs/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blogs/" id="logo">cdkd123&#39;s notes</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blogs/" id="subtitle">一个写写画画的地方</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blogs/">Home</a>
        
          <a class="main-nav-link" href="/blogs/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blogs/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-kotlin每日一练_集合类的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/14/kotlin每日一练_集合类的使用/" class="article-date">
  <time datetime="2017-11-14T11:01:43.000Z" itemprop="datePublished">2017-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/14/kotlin每日一练_集合类的使用/">kotlin每日一练_集合类的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了kotlin也一个多月了，总想写点代码，但总有一些概念不清楚，刚好借着练习（打码）的时机，去复习下概念。</p>
<p><a href="https://kotlincn.net" target="_blank" rel="noopener">kotlin中文网</a>上面的资源已经相当多了。用于练习的资料，目测有：</p>
<ol>
<li><code>kotlin-koans</code> 一个已经写好测试代码，设计了很多任务，练习者只管完成任务就好了。相当方便。</li>
<li><code>kotlin-koans在线网站</code> 和1.一样，只不过，无须下载开发工具导入项目，一切工作在网页完成即可。</li>
<li><code>github的一些成熟开源项目</code> 不乏大厂的项目。可以多多关注。</li>
</ol>
<p>这一章，主要使用标准库的<code>Collections</code>的一些常用工具类函数，初试kotlin的威力。</p>
<p>这些函数<strong>包含但不限于</strong>：</p>
<h2 id="to"><a href="#to" class="headerlink" title="to"></a>to</h2><p>在<code>Collections</code>中，有很多以<code>to</code> 开头的方法，可以把接受对象，转换成指定对象。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list.toSet()</span><br><span class="line">list.toCollection(HashSet&lt;Int&gt;())</span><br><span class="line">list.toShortArray()</span><br><span class="line">// toLongArray</span><br><span class="line">// toShortArray</span><br><span class="line">// toDoubleArray</span><br><span class="line">// 。。。还有很多</span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a list containing only elements matching the given [predicate].</span><br><span class="line"> */</span><br><span class="line">public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; &#123;</span><br><span class="line">    return filterTo(ArrayList&lt;T&gt;(), predicate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法作用是根据指定条件返回数据。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val positiveNumbers = list.filter &#123; it &gt; 0 &#125;</span><br></pre></td></tr></table></figure>
<p>即返回list中大于0的元素集合。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a list containing the results of applying </span><br><span class="line"> * the given [transform] function to each element in the original collection.</span><br><span class="line"> */</span><br><span class="line">public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123;</span><br><span class="line">    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法返回的列表是原来集合的每个元素用<code>transform</code>方法处理之后的列表。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val squares = list.map &#123; it * it &#125; // 把list中每个item=item*item，最终形成一个新的list。</span><br></pre></td></tr></table></figure>
<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>还有个方法<code>flatMap</code>可以拆分列表。这个方法其实很有用，非常适合拆分一些字符串，按组分类的列表。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val result = listOf(&quot;abc&quot;, &quot;12&quot;).flatMap &#123; it.toList() &#125;</span><br><span class="line">result == listOf(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;1&apos;, &apos;2&apos;) // true, 因为flatMap已经把字符串拆分</span><br></pre></td></tr></table></figure>
<h2 id="any-all-cout-firstOrNull"><a href="#any-all-cout-firstOrNull" class="headerlink" title="any, all, cout, firstOrNull"></a>any, all, cout, firstOrNull</h2><p>这些方法也挺有用。</p>
<ol>
<li><code>any</code> 接受一个lambda表达式，根据条件查找集合中任何符合lambda表达式条件的元素，存在返回true，否则，返回false。</li>
<li><code>all</code> 接受一个lambda表达式，根据条件判断集合所有元素是否符合条件。</li>
<li><code>count</code> 接受一个lambda表达式，统计集合中所有符合条件的元素个数。</li>
<li><code>firstOrNull</code> 接受一个lambda表达式，查找第一个符合条件的元素。</li>
</ol>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun example2(list: List&lt;Int&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    val isZero: (Int) -&gt; Boolean = &#123; it == 0 &#125;</span><br><span class="line"></span><br><span class="line">    val hasZero: Boolean = list.any(isZero) // list是否有0</span><br><span class="line"></span><br><span class="line">    val allZeros: Boolean = list.all(isZero) // list是否所有值都是0</span><br><span class="line"></span><br><span class="line">    val numberOfZeros: Int = list.count(isZero) // list包含多少个0</span><br><span class="line"></span><br><span class="line">    val firstPositiveNumber: Int? = list.firstOrNull &#123; it &gt; 0 &#125; // 获取 list 里第一个大于0的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="maxBy"><a href="#maxBy" class="headerlink" title="maxBy"></a>maxBy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the first element yielding the largest value of </span><br><span class="line"> * the given function or `null` if there are no elements.</span><br><span class="line"> */</span><br><span class="line"> public inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Iterable&lt;T&gt;.maxBy(selector: (T) -&gt; R): T?</span><br></pre></td></tr></table></figure>
<p>返回第一个<code>最大值的元素</code>，当然这个<strong>最大</strong>，还是要根据给定的方法决定。如果没数据返回<code>null</code>.<br>当然，有max，就有相反的<code>min</code>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val max = listOf(1, 42, 4).max() // 返回42</span><br><span class="line">val longestString = listOf(&quot;a&quot;, &quot;b&quot;).maxBy &#123; it.length &#125; // 返回1</span><br></pre></td></tr></table></figure>
<h2 id="sortedBy"><a href="#sortedBy" class="headerlink" title="sortedBy"></a>sortedBy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Returns a list of all elements sorted according to natural sort order of the </span><br><span class="line"> * value returned by specified [selector] function.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>返回排序好的列表</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val result = listOf(&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;).sortedBy &#123; it.length &#125;</span><br><span class="line">result == listOf(&quot;a&quot;, &quot;cc&quot;, &quot;bbb&quot;) // 返回true</span><br></pre></td></tr></table></figure>
<h2 id="sumBy"><a href="#sumBy" class="headerlink" title="sumBy"></a>sumBy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the sum of all values produced by [selector] function applied </span><br><span class="line"> * to each element in the collection.</span><br><span class="line"> */</span><br><span class="line">public inline fun &lt;T&gt; Iterable&lt;T&gt;.sumBy(selector: (T) -&gt; Int): Int</span><br></pre></td></tr></table></figure>
<p>返回返回每个元素代入<code>selector</code>函数，返回结果的累加。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 3).sum() == 4</span><br><span class="line">listOf(&quot;a&quot;, &quot;b&quot;, &quot;cc&quot;).sumBy &#123; it.length &#125; == 4</span><br></pre></td></tr></table></figure>
<p>第一个累加列表的所有整数。<br>第二个累加列表的字符串长度。</p>
<h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Groups elements of the original collection by the key returned by </span><br><span class="line"> * the given [keySelector] function applied to each element and returns </span><br><span class="line"> * a map where each group key is associated with a list of corresponding elements.</span><br><span class="line"> * The returned map preserves the entry iteration order of the keys produced </span><br><span class="line"> * from the original collection.</span><br><span class="line"> * @sample samples.collections.Collections.Transformations.groupBy</span><br><span class="line"> */</span><br><span class="line">public inline fun &lt;T, K&gt; Iterable&lt;T&gt;.groupBy(keySelector: (T) -&gt; K): Map&lt;K, List&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这大段大段的注释，是在讲个什么鬼？<br>其实就是分组，每组有个key，所有元素就按这几个key分组。而且key是有序的。返回的结果，自然是个<code>Map&lt;K,List&lt;T&gt;&gt;</code>.</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val result = listOf(&quot;a&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;ccc&quot;, &quot;ad&quot;).groupBy &#123; it.length &#125;</span><br><span class="line"></span><br><span class="line">result == mapOf(1 to listOf(&quot;a&quot;, &quot;b&quot;), 2 to listOf(&quot;ba&quot;, &quot;ad&quot;), 3 to listOf(&quot;ccc&quot;)) // result的结果就是==后面的结果</span><br></pre></td></tr></table></figure>
<h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Splits the original collection into pair of lists,</span><br><span class="line"> * where *first* list contains elements for which [predicate] yielded `true`,</span><br><span class="line"> * while *second* list contains elements for which [predicate] yielded `false`.</span><br><span class="line"> */</span><br><span class="line">public inline fun &lt;T&gt; Iterable&lt;T&gt;.partition(predicate: (T) -&gt; Boolean): Pair&lt;List&lt;T&gt;, List&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这个方法作用是：把lists分割成一对lists。前一个list包含的元素作用到<code>predicate</code> = <code>true</code>, 后一个list包含的元素作用到<code>predicate</code> = <code>false</code>。</p>
<p><strong>示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 3, -4, 2, -11)</span><br><span class="line"></span><br><span class="line">// The details (how multi-assignment works) will be explained later in the &apos;Conventions&apos; task</span><br><span class="line">val (positive, negative) = numbers.partition &#123; it &gt; 0 &#125;</span><br><span class="line"></span><br><span class="line">positive == listOf(1, 3, 2)</span><br><span class="line">negative == listOf(-4, -11)</span><br></pre></td></tr></table></figure></p>
<p>这里，就不必多说了吧，正负数分成两个列表。代码中用到一个技巧：<a href="https://www.kotlincn.net/docs/reference/multi-declarations.html" target="_blank" rel="noopener"><strong>解构</strong></a></p>
<h2 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * Accumulates value starting with [initial] value and applying [operation] from </span><br><span class="line"> * left to right to current accumulator value and each element.</span><br><span class="line"> */</span><br><span class="line">public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (acc: R, T) -&gt; R): R</span><br></pre></td></tr></table></figure>
<p>从初始值 <code>initial</code>开始，从左到右累积 <code>operation</code> 计算的结果。有可能是累加，有可能是累乘。</p>
<p><strong>示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val result = listOf(1, 2, 3, 4).fold(1, &#123; partResult, element -&gt; element * partResult &#125;)</span><br><span class="line">result == 24  // true</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码就是从元素1，开始累乘，elment代表了<code>列表</code>需要每次<strong>累乘</strong>(其他代码中脑补替换该词)的元素。</p>
<h2 id="java与kotlin搞事情的不同之处"><a href="#java与kotlin搞事情的不同之处" class="headerlink" title="java与kotlin搞事情的不同之处"></a>java与kotlin搞事情的不同之处</h2><p>kotlin之所以宣称简洁，是因为他的代码真的简洁。同样一段代码，用java写，再用kotlin写会感觉极大的<code>轻松和简单</code>。</p>
<p>例如下面这段对list做了一些复杂操作，最后搞出个结果的<code>java函数</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public Collection&lt;String&gt; doSomethingStrangeWithCollection(Collection&lt;String&gt; collection) &#123;</span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; groupsByLength = Maps.newHashMap();</span><br><span class="line">    for (String s : collection) &#123;</span><br><span class="line">        List&lt;String&gt; strings = groupsByLength.get(s.length());</span><br><span class="line">        if (strings == null) &#123;</span><br><span class="line">            strings = Lists.newArrayList();</span><br><span class="line">            groupsByLength.put(s.length(), strings);</span><br><span class="line">        &#125;</span><br><span class="line">        strings.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maximumSizeOfGroup = 0;</span><br><span class="line">    for (List&lt;String&gt; group : groupsByLength.values()) &#123;</span><br><span class="line">        if (group.size() &gt; maximumSizeOfGroup) &#123;</span><br><span class="line">            maximumSizeOfGroup = group.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (List&lt;String&gt; group : groupsByLength.values()) &#123;</span><br><span class="line">        if (group.size() == maximumSizeOfGroup) &#123;</span><br><span class="line">            return group;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用kotlin写只需几行代码实现上述功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun doSomethingStrangeWithCollection(collection: Collection&lt;String&gt;): Collection&lt;String&gt;? &#123;</span><br><span class="line"></span><br><span class="line">    val groupsByLength = collection.groupBy &#123; s -&gt; s.length &#125;</span><br><span class="line"></span><br><span class="line">    return groupsByLength.values.maxBy &#123; group -&gt; group.size &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以使用kotlin将极大的提高我们的生产效率！！kotlin万岁！</p>
<p>参考：</p>
<p><a href="">#解构</a><br><a href="https://try.kotlinlang.org/#/Kotlin%20Koans/Collections/Introduction/TestShop.kt" target="_blank" rel="noopener">kotlin-koans</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/14/kotlin每日一练_集合类的使用/" data-id="cjh694n7b001be0qexvgj9332" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门-反射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/08/kotlin入门-反射/" class="article-date">
  <time datetime="2017-11-08T09:25:02.000Z" itemprop="datePublished">2017-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/08/kotlin入门-反射/">kotlin入门_反射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="kotlin的反射"><a href="#kotlin的反射" class="headerlink" title="kotlin的反射"></a>kotlin的反射</h2><p>程序运行时，我们经常会想获取一个类的属性，和方法名称，尤其是别人给了一个jar文件，通过反编译可以知道方法名称，参数，但就是不知道功能时。这时候，通过引用”方法“名称，并调用invoke()方法（java的方式）。kotlin会有自己的方式实现这些反射功能。</p>
<h2 id="类引用"><a href="#类引用" class="headerlink" title="类引用"></a>类引用</h2><p>一个类，在kotlin中，也能获取他的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val widget = MyClass::class</span><br></pre></td></tr></table></figure>
<p>这样就获取了类引用。</p>
<h2 id="绑定的类引用"><a href="#绑定的类引用" class="headerlink" title="绑定的类引用"></a>绑定的类引用</h2><p>子类在引用时，可以绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val widget: Widget = ...</span><br><span class="line">if(widget is GoodWidget) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们就获取一个Widget类或子类的引用。</p>
<h2 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun isOdd(x: Int): Boolean = x%2 != 0</span><br></pre></td></tr></table></figure>
<p>可以把这个函数当做值传递，例如，传递给一个函数的参数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val list: List = listOf(1, 2, 3)</span><br><span class="line">val result = list.filter(::isOdd) // 结果[1,3]</span><br></pre></td></tr></table></figure>
<p>甚至可以用一个”显示声明的变量“存储它，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val odd: (Int) -&gt; Boolean = isOdd</span><br></pre></td></tr></table></figure>
<p>在当前上下文可以这样引用，但是，如果引用一个其他类的成员函数，或者属性，可以<code>String::toCharArray</code></p>
<h2 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h2><p>函数可以引用，当然属性也可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val x = 5</span><br><span class="line"></span><br><span class="line">fun print() &#123;</span><br><span class="line">	println(::x.get()) // 5</span><br><span class="line">	println(::x.name) // x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，可变属性还可以访问<code>::x.set()</code>这样的方法。</p>
<h2 id="和java反射的互操作"><a href="#和java反射的互操作" class="headerlink" title="和java反射的互操作"></a>和java反射的互操作</h2><p>标准库已经实现了kotlin-&gt;java的反射映射。<br>想要在kotlin中，获取一个java类的属性或者背后字段，可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import kotlin.reflect.jvm.*</span><br><span class="line"></span><br><span class="line">class A(val p: Int) </span><br><span class="line"></span><br><span class="line">fun printjava() &#123;</span><br><span class="line">	println(A::p.javaGetter) // 输出public final int A.p.getP()</span><br><span class="line">   println(A::p.javaField) // 输出private final int A.p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的，想要获取java对应的kotlin字段，使用扩展属性：.kotlin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun getKClass(o: Any): KClass&lt;Any&gt; = o.javaClass.kotlin</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/08/kotlin入门-反射/" data-id="cjh694n6a000ce0qe8tq79vbo" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/反射/">反射</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门_偏函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/08/kotlin入门_偏函数/" class="article-date">
  <time datetime="2017-11-08T04:53:45.000Z" itemprop="datePublished">2017-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/08/kotlin入门_偏函数/">kotlin入门_偏函数.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="偏函数的概念"><a href="#偏函数的概念" class="headerlink" title="偏函数的概念"></a>偏函数的概念</h2><p>针对有很多参数的函数，使用起来，有时会感觉非常不便，例如，有些参数，我们希望是默认值，用的时候，直接传变量就行了。kotlin的<em>函数默认参数</em>似乎可以做到这点。可是如果不同地方模块，默认参数值不一样呢？尤其是函数被大量调用的时候，我们迫切需要一种方式，解决这个问题。</p>
<h1 id="这时候，偏函数（patial-function）就派上用场了。"><a href="#这时候，偏函数（patial-function）就派上用场了。" class="headerlink" title="这时候，偏函数（patial function）就派上用场了。"></a>这时候，偏函数（patial function）就派上用场了。</h1><p>我们举个例子来说明偏函数的好处：</p>
<p>有一串“数字字符串”，我们需要根据需要，转换成二进制，八进制，十进制。且不谈系统api，自己先实现一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun init(base: Int = 10, x: String) &#123;</span><br><span class="line">	var i = Integer.valueOf(x)</span><br><span class="line">	when(base) &#123;</span><br><span class="line">		2 -&gt; get2Dex(i)</span><br><span class="line">		8 -&gt; get8Dex(i)</span><br><span class="line">		10 -&gt; get10Dex(i)</span><br><span class="line">		else -&gt; throw NullException()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要持续转化几个二进制数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init(2, &quot;15&quot;)</span><br><span class="line">init(2, &quot;16&quot;)</span><br><span class="line">init(2, &quot;17&quot;)</span><br></pre></td></tr></table></figure>
<p>这段代码，出现了重复传参。并不是最简洁的写法，我们期望是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init2(&quot;15&quot;)</span><br><span class="line">init2(&quot;16&quot;)</span><br><span class="line">init2(&quot;17&quot;)</span><br></pre></td></tr></table></figure></p>
<p>偏函数就是定义一个函数，通过设定默认值，简化不必要的参数调用。从而简化代码。</p>
<p>之前我们学过<em>柯里化</em>，即把多个参数转化为多个单个参数的函数。<br>对于上面的init函数，我们定义一个柯里化函数curry()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;P, V, R&gt; Function2&lt;P, V, R&gt;.curry(): (p: P) -&gt; (v: V) -&gt; R = </span><br><span class="line">	fun(p: P) = fun(v: V) = this(p, v)</span><br></pre></td></tr></table></figure></p>
<p>为了实现上面init2()的功能，我们先给init第一个参数设置个默认值, 使用时，就达到简化效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val init1 = ::init.curry()(2)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">完整代码：</span><br></pre></td></tr></table></figure>
<p>fun <p, v,="" r=""> Function2<p, v,="" r="">.curry(): (p: P) -&gt; (v: V) -&gt; R =<br>    fun(p: P) = fun(v: V) = this(p, v)</p,></p,></p>
<p>fun get2Dex(i: Int): String {<br>    var str = “”<br>    var tmp = i </p>
<pre><code>while(tmp != 0) {
   str = &quot;&quot; + (tmp and 0x1) + str
   tmp = tmp ushr 1
}
return str
</code></pre><p>}</p>
<p>fun get8Dex(i: Int): String {<br>    return “8-dex:” + i<br>}</p>
<p>fun get10Dex(i: Int): String {<br>    return “10-dex:” + i<br>} </p>
<p>fun init(base: Int = 10, str: String) {<br>        var i = Integer.valueOf(str)<br>        val result = when(base) {<br>        2 -&gt; get2Dex(i)<br>        8 -&gt; get8Dex(i)<br>        10 -&gt; get10Dex(i)<br>        else -&gt; “”<br>    }<br>    println(“result:” + result)<br>} </p>
<p>fun main(args: Array<string>) {</string></p>
<pre><code>val init2 = ::init.curry()(2)
init2(&quot;-15&quot;)
init2(&quot;16&quot;)
init2(&quot;17&quot;)
init2(&quot;18&quot;)
</code></pre><p>} </p>
<p>```</p>
<p>不足之处：<br>一开始写init函数时，把base放在第二个参数，第一个放字符串，在使用curry时，就显得比较为难了。完全没办法给base设置默认值。这个问题有待解决。</p>
<p>这里引用一段区别currying化和偏函数的描述结尾：</p>
<ul>
<li>偏函数应用是找一个函数，固定其中的几个参数值，从而得到一个新的函数。</li>
<li>函数加里化是一种使用匿名单参数函数来实现多参数函数的方法。</li>
<li>函数加里化能够让你轻松的实现某些偏函数应用。</li>
<li>有些语言(例如 Haskell, OCaml)所有的多参函数都是在内部通过函数加里化实现的。</li>
</ul>
<p>参考：<br><a href="http://www.vaikan.com/currying-partial-application/" target="_blank" rel="noopener">函数curry化和偏函数的关系</a><br><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819893624a7edc0e3e3df4d5d852a352b037c93ec000" target="_blank" rel="noopener">python偏函数</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/08/kotlin入门_偏函数/" data-id="cjh694n6g000ge0qervge772v" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/偏函数-partial-function/">偏函数 (partial function)</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门_函数复合与柯里化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/07/kotlin入门_函数复合与柯里化/" class="article-date">
  <time datetime="2017-11-07T06:24:30.000Z" itemprop="datePublished">2017-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blogs/categories/kotlin/">kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/07/kotlin入门_函数复合与柯里化/">kotlin入门-函数复合与curry化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数复合的基本感念"><a href="#函数复合的基本感念" class="headerlink" title="函数复合的基本感念"></a>函数复合的基本感念</h2><p>在数学表达式中，经常有u = f(x), v = g(y), 则 y = f(g(x)) 就是y关于x的复合函数，复合函数把前一个关于x的函数u的结果，作为后者函数v的输入，最后得出复合函数的结果。就是几个简单函数嵌套成一个复杂函数。</p>
<p>kotlin也能表达这种复杂的数学公式。</p>
<h2 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h2><p>举个简单的栗子，第一个函数sum(x) 让 x + 1, 第二个函数 mut(x) 让 x * 3，现在我们想复合函数 sum, mut, 得到一个新函数。怎么办?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(val x: Int) = x + 1</span><br><span class="line"></span><br><span class="line">fun mut(val x: Int) = x * 3</span><br></pre></td></tr></table></figure>
<p>定义复合函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123;</span><br><span class="line">    return &#123; x -&gt; f(g(x)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就定义了比较通用的复合函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun sum(x: Int): Int = x + 1</span><br><span class="line"></span><br><span class="line">fun mut(x: Int): Int = (x * 3)</span><br><span class="line"></span><br><span class="line">fun &lt;A, B, R&gt; compose(f: (A) -&gt; B, g: (B) -&gt; R): (A) -&gt; R &#123;</span><br><span class="line">    return &#123; x -&gt; g(f(x)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">     </span><br><span class="line">    val funx = compose(::sum, ::mut)</span><br><span class="line">    funx(5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，传给类型参数A，B，R都是Int，把函数sum的结果，当做参数，传给mut，最终计算结果。在return语句中，使用了一个lambda表达式，lambda表达式和匿名函数等价的。相当于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return fun result(x: A) = g(f(x))</span><br></pre></td></tr></table></figure>
<p>计算过程就是：x+1 = 6, x = 6, x*3 = 18.</p>
<h2 id="另一种复合函数的写法"><a href="#另一种复合函数的写法" class="headerlink" title="另一种复合函数的写法"></a>另一种复合函数的写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">infix fun &lt;A, P, R&gt; Function1&lt;A, P&gt;.compose(function: Function1&lt;P, R&gt;): Function1&lt;A, R&gt; &#123;</span><br><span class="line">  return fun(a: A): R &#123;</span><br><span class="line">      return function.invoke(this.invoke(a))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val fun1 = &#123; i : Int -&gt; i + 1 &#125;</span><br><span class="line">    val fun2 = &#123; i : Int -&gt; i * 3 &#125;</span><br><span class="line">    val result_12 = fun1 compose fun2 //复合后的函数：result_12</span><br><span class="line">    println(result_12( 5 ))  //调用复合后的函数，结果是 14</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result_12 = fun1 compose fun2</span><br></pre></td></tr></table></figure>
<p>这是一种<a href="https://www.kotlincn.net/docs/reference/functions.html#中缀表示法" target="_blank" rel="noopener">中缀表示法</a>。</p>
<h2 id="函数的科里化（currying）基本概念"><a href="#函数的科里化（currying）基本概念" class="headerlink" title="函数的科里化（currying）基本概念"></a>函数的科里化（currying）基本概念</h2><p>在scala，javascript中有这个概念–<strong>函数柯里化</strong>，定义如下：</p>
<ul>
<li><p>柯里化(Currying) 指的是将一个接收多个参数的函数分解成多个接收单个参数的函数的一种技术。</p>
</li>
<li><p>柯里化是一种简化代码的方法。实现了point-free风格，最终让代码变得清晰，易懂。</p>
</li>
<li><p>kotlin自身没有currying的相关方法。我们可以自己用kotlin实现一个包含3个参数x，y，z的函数，转化为只用单个参数的3个函数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;P1, P2, P3, R&gt; Function3&lt;P1, P2, P3, R&gt;.currying():</span><br><span class="line">        (p1: P1) -&gt; (p2: P2) -&gt; (p3: P3) -&gt; R</span><br><span class="line">        = fun(p1: P1) = fun(p2: P2) = fun(p3: P3) = this(p1, p2, p3)</span><br><span class="line"></span><br><span class="line">fun calculate(x: Int, y: Int, z: Int) = x * y + z</span><br><span class="line">val curriedCalculate = ::calculate.currying()</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">	val temp2Cal = (::calculate.currying())(2)</span><br><span class="line">	val tempCalculate = (::calculate.currying())(2)(2)</span><br><span class="line">	println(calculate(2,2,2))</span><br><span class="line">	println(curriedCalculate(2)(2)(2))</span><br><span class="line">	println(temp2Cal(2)(4))</span><br><span class="line">	println(tempCalculate(2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码把带3个参数的函数calculate，用自定义的柯里化函数<code>currying()</code>,分解成单个参数的函数。而使用者用的时候，不必关心运算过程。从而实现代码的简化。</p>
<h2 id="扩展-Pointfree风格"><a href="#扩展-Pointfree风格" class="headerlink" title="扩展 Pointfree风格"></a>扩展 Pointfree风格</h2><p>简单说，<a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="noopener">Pointfree</a>就是运算过程抽象化，处理一个值，但是不提到这个值。这样做有很多好处，它能够让代码更清晰和简练，更符合语义，更容易复用，测试也变得轻而易举。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>另外我读了阮一峰老师的<code>Point-Free</code>，又在思考如何用kotlin 写出pointfree风格的代码。下面这段代码是为了实现一段pointfree风格的<a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html#Pointfree的示例一" target="_blank" rel="noopener">js</a>功能。</p>
<h2 id="pointfree-示例代码"><a href="#pointfree-示例代码" class="headerlink" title="pointfree 示例代码"></a>pointfree 示例代码</h2><p>我们想找出一段字符串中，最长的单词长度, js的pointfree风格写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;Lorem ipsum dolor sit amet consectetur adipiscing elit&apos;;</span><br><span class="line"></span><br><span class="line">// 以空格分割单词</span><br><span class="line">var splitBySpace = s =&gt; s.split(&apos; &apos;);</span><br><span class="line"></span><br><span class="line">// 每个单词的长度</span><br><span class="line">var getLength = w =&gt; w.length;</span><br><span class="line"></span><br><span class="line">// 词的数组转换成长度的数组</span><br><span class="line">var getLengthArr = arr =&gt; R.map(getLength, arr); </span><br><span class="line"></span><br><span class="line">// 返回较大的数字</span><br><span class="line">var getBiggerNumber = (a, b) =&gt; a &gt; b ? a : b;</span><br><span class="line"></span><br><span class="line">// 返回最大的一个数字</span><br><span class="line">var findBiggestNumber = arr =&gt; R.reduce(getBiggerNumber, 0, arr);</span><br><span class="line"></span><br><span class="line">var getLongestWordLength = R.pipe(</span><br><span class="line">  R.split(&apos; &apos;),</span><br><span class="line">  R.map(R.length),</span><br><span class="line">  R.reduce(R.max, 0)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(getLongestWordLength(str));</span><br></pre></td></tr></table></figure>
<p><a href="http://jsbin.com/vutoxis/edit?js,console" target="_blank" rel="noopener">运算结果</a></p>
<p>我们用<code>kotlin代码</code>实现一遍，发现其实也是很容易的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Lorem ipsum dolor sit amet consectetur adipiscing elit&quot;</span><br><span class="line"></span><br><span class="line">fun &lt;A, B, C, D&gt; compose(f: (C) -&gt; D, g: (B) -&gt; C, h: (A) -&gt; B): (A) -&gt; D &#123;</span><br><span class="line">    return &#123; x -&gt; f(g(h(x))) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以空格分割单词</span><br><span class="line">fun splitWithSpace(str: String): List&lt;String&gt; = str.split(&quot; &quot;)</span><br><span class="line"></span><br><span class="line">// 词的数组转换成长度的数组</span><br><span class="line">fun  getLengthArr(list: List&lt;String&gt;): List&lt;Int&gt; = list.map&#123;</span><br><span class="line">    it -&gt; it.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回2个整数的较大的值</span><br><span class="line"> fun getBiggerOne(a: Int, b: Int): Int = if(a &gt; b) a else b</span><br><span class="line"></span><br><span class="line">// 返回整形数组最大值</span><br><span class="line">fun getBiggestNumber(list: List&lt;Int&gt;): Int </span><br><span class="line">	= list.reduce &#123; r, s -&gt; getBiggerOne(r, s) &#125;</span><br><span class="line"></span><br><span class="line">fun findBiggestWord(str: String): Int &#123;</span><br><span class="line"> </span><br><span class="line">//     var list = splitWithSpace(str)</span><br><span class="line">//     var lengthList = getLengthArr(list)</span><br><span class="line">//     var bigNumber = getBiggestNumber(lengthList)</span><br><span class="line"></span><br><span class="line">   val lengthArr = compose(::getBiggestNumber, ::getLengthArr, ::splitWithSpace)</span><br><span class="line"></span><br><span class="line">	return lengthArr(str)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//调用</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val result = findBiggestWord(str)</span><br><span class="line">    println(&quot;result:&quot; + result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，我们在实现过程中，<strong>做到了关心运算的过程，即分割字符串，转化成数组，获取其中的最大值；每个步骤都有语义化的名称，非常的清晰。</strong> 这就是 Pointfree 风格的优势。<strong>全程并不是很关心数据。而是算法！</strong></p>
<p>参考：<br><a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/reduce.html" target="_blank" rel="noopener">reduce</a><br><a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="noopener">pointfree编程风格</a><br><a href="http://juhezi.me/2017/10/09/kotlin-carrying/" target="_blank" rel="noopener">kotlin的柯里化</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/07/kotlin入门_函数复合与柯里化/" data-id="cjh694n6r000me0qez38s9t1t" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/复合函数/">复合函数</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门_高阶函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/03/kotlin入门_高阶函数/" class="article-date">
  <time datetime="2017-11-03T08:24:09.000Z" itemprop="datePublished">2017-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blogs/categories/kotlin/">kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/03/kotlin入门_高阶函数/">kotlin入门_高阶函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>把函数当做参数的函数称为<code>高阶函数</code>。举个普通的栗子：lock函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T): T &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    try &#123;</span><br><span class="line">        return body()</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如这是一个被多线程调用的函数，为了保持同步，我们传一个锁对象进去。执行body函数的过程，lock上锁，在<code>finally</code>语句块解锁。</p>
<p><code>body:() -&gt; T</code> 这个函数被当做参数传给lock函数，这就是高阶函数。</p>
<p>这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun toBeSynchronized() = sharedResource.operation()</span><br><span class="line">val result = lock(lock, ::toBeSynchronized)</span><br></pre></td></tr></table></figure>
<p>这是高阶函数的基本用法，我们会经常用到一些高阶函数，比如这些：</p>
<p>标准库里又很多<strong>常见高阶函数</strong>，例如:</p>
<ul>
<li><p>run() 、with() 和 let() 函数：接受返回 R 类型的函数，返回 R 类型;</p>
</li>
<li><p>apply() 和 also() 函数：接受返回 Unit 类型的函数，返回 T 类型;</p>
</li>
<li><p>takeIf() 和 takeUnless() 函数：接受返回 (T) -&gt; Boolean 类型函数，返回 T? 类型;</p>
</li>
<li><p>repeat() 函数：执行指定次数的操作。 </p>
</li>
</ul>
<h2 id="run-、with-和-let"><a href="#run-、with-和-let" class="headerlink" title="run() 、with() 和 let()"></a>run() 、with() 和 let()</h2><p>这几个函数的源代码相当简单，我们看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;R&gt; run(block: () -&gt; R): R = block()</span><br><span class="line">inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</span><br><span class="line">inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</span><br><span class="line">inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</span><br></pre></td></tr></table></figure>
<p><a href="#ref">参考</a></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>通常，更好的做法是，传递一个lambda表达式，给lock函数，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock(lock, &#123;sharedResource.operation()&#125;)</span><br></pre></td></tr></table></figure>
<p>所谓lambda表达式，有这么一些特点：</p>
<ol>
<li>lambda 表达式总是被大括号括着</li>
<li>其参数（如果有的话）在 -&gt; 之前声明（参数类型可以省略）；</li>
<li>函数体（如果存在的话）在 -&gt; 后面。</li>
</ol>
<p>kotlin中有个约定，如果函数最后的参数是<em>函数</em>，并且传递的是lambda表达式，可以把lambda表达式函数体放在括号外边。上面代码可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock(lock) &#123;</span><br><span class="line">	sharedResource.operation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 一个 lambda 表达式或匿名函数是一个“函数字面值”，即一个未声明的函数， 但立即做为表达式传递。考虑下面的例子：</p>
<h2 id="it：单个参数的隐式名称"><a href="#it：单个参数的隐式名称" class="headerlink" title="it：单个参数的隐式名称"></a>it：单个参数的隐式名称</h2><p>另一个有用的约定是，如果函数字面值只有一个参数， 那么它的声明可以省略（连同 -&gt;），其名称是 <code>it</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ints.map &#123; it * 2 &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="下划线用于未使用的变量（自-1-1-起）"><a href="#下划线用于未使用的变量（自-1-1-起）" class="headerlink" title="下划线用于未使用的变量（自 1.1 起）"></a>下划线用于未使用的变量（自 1.1 起）</h2><p>如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称：<br><code>map.forEach { _, value -&gt; println(&quot;$value!&quot;)</code></p>
<h2 id="在-lambda-表达式中解构（自-1-1-起）"><a href="#在-lambda-表达式中解构（自-1-1-起）" class="headerlink" title="在 lambda 表达式中解构（自 1.1 起）"></a>在 lambda 表达式中解构（自 1.1 起）</h2><p>在 lambda 表达式中解构是作为解构声明的一部分描述的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123; a //-&gt; …… &#125; // 一个参数 it作为默认参数</span><br><span class="line">&#123; a, b //-&gt; …… &#125; // 两个参数</span><br><span class="line">&#123; (a, b) //-&gt; …… &#125; // 一个解构对</span><br><span class="line">&#123; (a, b), c //-&gt; …… &#125; // 一个解构对以及其他参数</span><br><span class="line"></span><br><span class="line">// 判断变量x是否大于5</span><br><span class="line">compare(&#123; x -&gt; x &gt; 5&#125;) 一个参数 it作为默认参数</span><br><span class="line"></span><br><span class="line">// 判断x是否大于y ,就传2个参数</span><br><span class="line">compare(&#123;x, y -&gt; (x - y) &gt; 0&#125;) </span><br><span class="line"></span><br><span class="line">// 判断一个map中的某个item的x&gt;y，解构对的用法</span><br><span class="line">compare(&#123;(x, y) -&gt; x &gt; y)&#125;)</span><br><span class="line"></span><br><span class="line">// 结构对+其他参数</span><br><span class="line">compare(&#123;x, y), c -&gt; x &gt; (y + c))</span><br></pre></td></tr></table></figure>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>参考c++语言特性的移植。kotlin也用<em>inline</em>修饰符修饰。</p>
<p>当然，把root函数放在循环中不是个不明智的选择，但想象一下，在某个程序上下文内必须频繁地调用某个类似root的函数，其调用函数的花销会有多大：当遇到普通函数的调用指令时，程序会保存当前函数的执行现场，将函数中的局部变量以及函数地址压入堆栈，然后再将即将调用的新函数加载到内存中，这要经历复制参数值、跳转到所调用函数的内存位置、执行函数代码、存储函数返回值等过程，当函数执行完后，再获取之前正在调用的函数的地址，回去继续执行那个函数，运行时间开销简直太多了。<br>C++内联函数提供了替代函数调用的方案，通过inline声明，编译器首先在函数调用处使用函数体本身语句替换了函数调用语句，然后编译替换后的代码。因此，通过内联函数，编译器不需要跳转到内存其他地址去执行函数调用，也不需要保留函数调用时的现场数据。</p>
<p><a href="http://www.cnblogs.com/QG-whz/p/4641479.html" target="_blank" rel="noopener">c++内联函数</a></p>
<p>inline 修饰符<strong>影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处。</strong></p>
<h2 id="禁止内联"><a href="#禁止内联" class="headerlink" title="禁止内联"></a>禁止内联</h2><p>有时候，在一个内联函数的参数中，禁止作为参数的函数内联，可以使用<em>noinline</em>禁止内联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) &#123;</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非局部返回"><a href="#非局部返回" class="headerlink" title="非局部返回"></a>非局部返回</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun foo() &#123;</span><br><span class="line">    ordinaryFunction &#123;</span><br><span class="line">        return // 错误：不能使 `foo` 在此处返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种返回是禁止的。因为lambda表达式不能让包含他的函数返回。</p>
<p>如果ordinaryFunction是内联函数，则可以，因为内联函数的话，编译器会在调用出替换这段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun foo() &#123;</span><br><span class="line">    inlineFunction &#123;</span><br><span class="line">        return // 错误：不能使 `foo` 在此处返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体化的类型参数"><a href="#具体化的类型参数" class="headerlink" title="具体化的类型参数"></a>具体化的类型参数</h2><pre><code>inline fun &lt;reified T&gt; TreeNode.findParentOfType(): T? {
    var p = parent
    while (p != null &amp;&amp; p !is T) {
        p = p.parent
    }
    return p as T?
}
</code></pre><p><span id="ref">参考：</span></p>
<p><a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/index.html" target="_blank" rel="noopener">常见高阶函数</a><br><a href="http://www.jianshu.com/p/03db2203e0f2" target="_blank" rel="noopener">经常用高阶函数</a><br><a href="https://zhuanlan.zhihu.com/p/27159901" target="_blank" rel="noopener">常见高阶函数</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/03/kotlin入门_高阶函数/" data-id="cjh694n750014e0qemm5gcwg1" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/高阶函数/">高阶函数</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门_数据类密封类嵌套类内部类枚举" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/01/kotlin入门_数据类密封类嵌套类内部类枚举/" class="article-date">
  <time datetime="2017-11-01T09:18:36.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blogs/categories/kotlin/">kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/01/kotlin入门_数据类密封类嵌套类内部类枚举/">kotlin入门-几种常见类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>在写java代码时，经常会使用各种bean对象，用来表示各种类型的数据。我们在kotlin中有专门针对这种“数据类”的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data class A &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用关键词<em>data</em>修饰，数据类的定义有很多限制，可以参见<a href="https://www.kotlincn.net/docs/reference/data-classes.html" target="_blank" rel="noopener">数据类的限制</a>, 但同时也会给编程带来很多便利，例如编译器<em>自动根据构造函数生成如下代码</em>：</p>
<ul>
<li>equals()/hashCode() 对；</li>
<li>toString() 格式是 “User(name=John, age=42)”；</li>
<li>componentN() 函数 按声明顺序对应于所有属性；</li>
<li>copy() 函数（见下文）。</li>
</ul>
<h3 id="copy方法"><a href="#copy方法" class="headerlink" title="copy方法"></a>copy方法</h3><p>在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。对于上文的 User 类，其实现会类似下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun copy(name: String = this.name, age: Int = this.age) = User(name, age)     </span><br><span class="line">这让我们可以写：</span><br><span class="line">val jack = User(name = &quot;Jack&quot;, age = 1)</span><br><span class="line">val olderJack = jack.copy(age = 2)</span><br></pre></td></tr></table></figure></p>
<h3 id="数据类和数据解构"><a href="#数据类和数据解构" class="headerlink" title="数据类和数据解构"></a>数据类和数据解构</h3><p>我们还可以采用结构获取数据类对象的相关属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val jane = User(&quot;Jane&quot;, 35)</span><br><span class="line">val (name, age) = jane</span><br><span class="line">println(&quot;$name, $age years of age&quot;) // 输出 &quot;Jane, 35 years of age&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="标准数据类"><a href="#标准数据类" class="headerlink" title="标准数据类"></a>标准数据类</h3><p>标准库提供了 Pair 和 Triple。尽管在很多情况下命名数据类是更好的设计选择， 因为它们通过为属性提供有意义的名称使代码更具可读性。</p>
<h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>kotlin中，我们使用sealed修饰一个类，用来表示密封类。</p>
<ul>
<li>受限的类继承结构(有限集合的类型,不能有任何其他类型)</li>
<li>密封类和枚举很像，枚举类的值只有一个，密封类的子类却可以有多个实例。</li>
<li>密封类自身抽象，不能实例化。</li>
<li>密封类所有子类都得定义在同一个文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sealed class Expr</span><br><span class="line">data class Const(val number: Double) : Expr()</span><br><span class="line">data class Sum(val e1: Expr, val e2: Expr) : Expr()</span><br><span class="line">object NotANumber : Expr()</span><br></pre></td></tr></table></figure>
<p>密封类常用于when语句，可以简单的覆盖到密封类的所有子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun party(exp : Expr) : Double = when(exp) &#123;</span><br><span class="line">	exp is Const -&gt; exp.number</span><br><span class="line">	exp is Sum -&gt; party(exp.e1) + party(exp.e2)</span><br><span class="line">	exp is NotANumber -&gt; Double.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>在类的内部，还可以嵌套定义类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">	class B &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类就是用<strong>inner</strong>修饰的嵌套类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">	innner class B &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>使用对象表达式创建匿名内部类实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(object: MouseAdapter() &#123;</span><br><span class="line">    override fun mouseClicked(e: MouseEvent) &#123;</span><br><span class="line">        // ……</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                            </span><br><span class="line">    override fun mouseEntered(e: MouseEvent) &#123;</span><br><span class="line">        // ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果对象是函数式 Java 接口（即具有单个抽象方法的 Java 接口）的实例， 你可以使用带接口类型前缀的lambda表达式创建它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val listener = ActionListener &#123; println(&quot;clicked&quot;) &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数据类和密封类，都是为特殊需求设计的类；嵌套类和内部类，匿名内部类为了方便组织类之间的关系而设计的。<br>需要注意的就是数据类，会自动生成一些常用方法。例如<code>componentN(), copy()</code>方法等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/01/kotlin入门_数据类密封类嵌套类内部类枚举/" data-id="cjh694n6x000ue0qev9ckyxcz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门_伴生对象与扩展方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/01/kotlin入门_伴生对象与扩展方法/" class="article-date">
  <time datetime="2017-11-01T09:18:36.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blogs/categories/kotlin/">kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/01/kotlin入门_伴生对象与扩展方法/">kotlin入门_伴生对象与扩展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>在java中，一些静态字段或方法，经常被static修饰，定义成静态的，kotlin利用伴生对象取代了这一做法。具体的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">	companion object B &#123; </span><br><span class="line">		val instance: A = A()</span><br><span class="line">		val x = 5</span><br><span class="line">		fun test() &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用B.instance，就可以获取实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val a = A.B.instance // ok</span><br><span class="line">a.B.test() // error</span><br><span class="line">A.B.test() // ok</span><br></pre></td></tr></table></figure>
<h2 id="伴生对象的一些困惑"><a href="#伴生对象的一些困惑" class="headerlink" title="伴生对象的一些困惑"></a>伴生对象的一些困惑</h2><p>刚开始学习kotlin的时候，可能会对<code>companion object{}</code>和<code>const</code>关键字弄混淆，二者有如下区别:     </p>
<ul>
<li>Kotlin用<code>对象表达式和对象声明</code>实现Java匿名内部类这种情况，即匿名类的实现对象为object。</li>
<li><code>companion object{}</code>伴生对象，虽然调用的时候类似<code>static</code>，但它依然是对象的实例成员，并且可以实现接口</li>
</ul>
<p><code>const</code> 常量的含义</p>
<ul>
<li>用于String或基本类型进行初始化；</li>
<li>没有自定义getter；</li>
<li>修饰对象成员或顶级（Top-level）。会更像<code>static final</code>的常量</li>
</ul>
<h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>kotlin提供了一种<code>扩展类功能的机制</code> – 扩展方法。通过扩展方法，我们可以对像<code>Array</code>这样的类增加新功能。</p>
<p>声明一个<em>扩展函数</em>，我们需要用一个<em>接收者类型</em>也就是被扩展的类型来作为他的前缀。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun Array&lt;Int&gt;.swap(index1: Int, index2: Int) &#123;</span><br><span class="line">    val tmp = this[index1] // “this”对应该列表</span><br><span class="line">    this[index1] = this[index2]</span><br><span class="line">    this[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码为<code>Array&lt;Int&gt;</code>添加一个swap 函数。</p>
<p>现在我们用任意的<code>Array&lt;Int&gt;</code>可以使用<code>swap</code>函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val arr = Array&lt;Int&gt;(2, 3, 4)</span><br><span class="line">arr.swap(1, 2)</span><br></pre></td></tr></table></figure>
<p>我们还可以泛型化该函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; Array&lt;T&gt;.swap(index1: Int, index2: Int) &#123;</span><br><span class="line">	  val tmp = this[index1] // “this”对应该列表</span><br><span class="line">    this[index1] = this[index2]</span><br><span class="line">    this[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展是静态解析的"><a href="#扩展是静态解析的" class="headerlink" title="扩展是静态解析的"></a>扩展是静态解析的</h2><ul>
<li>扩展不能真正的修改他们所扩展的类。</li>
</ul>
<p><strong>通过定义一个扩展，你并没有在一个类中插入新成员，仅仅是可以通过该类型的变量用点表达式去调用这个新函数</strong>。</p>
<p>我们想强调的是扩展函数是静态分发的，即他们<em>不是</em>接收者类型的虚方法。这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的，而不是由表达式运行时求值结果决定的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">open class C</span><br><span class="line">class D: C()</span><br><span class="line">fun C.foo() = &quot;c&quot;</span><br><span class="line">fun D.foo() = &quot;d&quot;</span><br><span class="line">fun printFoo(c: C) &#123;</span><br><span class="line">    println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line">printFoo(D())</span><br></pre></td></tr></table></figure>
<p>打印出来的是<code>c</code>. 因为c.foo() 取决于他的声明，而不是实际对象类型。</p>
<ul>
<li>扩展相同的成员函数</li>
</ul>
<p>如果一个类已经有方法，我们又需要扩展相同签名的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">	fun sum() &#123;</span><br><span class="line">		println(&quot;ok&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun A.sum() &#123;</span><br><span class="line">	println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们调用：A.sum()，总是会调用<em>成员函数</em>。即输出”ok”。</p>
<h2 id="可空接收者"><a href="#可空接收者" class="headerlink" title="可空接收者"></a>可空接收者</h2><p>注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为<code>null</code>，并且可以在函数体内检测 <code>this == null</code>，这能让你在没有检测<code>null</code>的时候调用Kotlin中的<code>toString()</code>：检测发生在扩展函数的内部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun Any?.toString(): String &#123;</span><br><span class="line">    if (this == null) return &quot;null&quot;</span><br><span class="line">    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()</span><br><span class="line">    // 解析为 Any 类的成员函数</span><br><span class="line">    return toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><p>和函数类似，Kotlin 支持扩展属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int</span><br><span class="line">    get() = size - 1</span><br></pre></td></tr></table></figure>
<p>注意：由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 <code>getters/setters</code> 定义。<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val Foo.bar = 1 // 错误：扩展属性不能有初始化器</span><br></pre></td></tr></table></figure>
<h2 id="扩展伴生对象"><a href="#扩展伴生对象" class="headerlink" title="扩展伴生对象"></a>扩展伴生对象</h2><p>前面提到，一个类可以定义伴生对象，也可以针对伴生对象扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar.goo</span><br><span class="line"> class A  &#123;</span><br><span class="line"> 		companion object &#123;</span><br><span class="line"> 			</span><br><span class="line"> 		&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> fun A.Companion.sum() &#123;</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时，仍然以<code>A.sum()</code>形式调用。</p>
<h2 id="扩展作用域"><a href="#扩展作用域" class="headerlink" title="扩展作用域"></a>扩展作用域</h2><p>如果想在别的文件或类中调用定义的扩展，可以使用导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar</span><br><span class="line">fun Baz.goo() &#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>导入扩展方法名，或者所有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.example.usage</span><br><span class="line"></span><br><span class="line">import foo.bar.goo // 导入所有名为“goo”的扩展</span><br><span class="line">                   // 或者</span><br><span class="line">import foo.bar.*   // 从“foo.bar”导入一切</span><br><span class="line"></span><br><span class="line">fun usage(baz: Baz) &#123;</span><br><span class="line">    baz.goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展分发者与接受者"><a href="#扩展分发者与接受者" class="headerlink" title="扩展分发者与接受者"></a>扩展分发者与接受者</h2><p>略~~</p>
<h2 id="扩展设计的动机"><a href="#扩展设计的动机" class="headerlink" title="扩展设计的动机"></a>扩展设计的动机</h2><p>在java中的<code>Utils</code>太多太多，每次使用某个方法，就要调用Utils.xxx(), Utils.zzz(),  很不方便，使用扩展，更高效，灵活。</p>
<p>参考：<a href="http://www.jianshu.com/p/7bca7dbaa40b" target="_blank" rel="noopener">单例与伴生对象</a><br>來源：简书</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/01/kotlin入门_伴生对象与扩展方法/" data-id="cjh694n6o000ke0qe70onc962" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门_属性和属性委托" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/01/kotlin入门_属性和属性委托/" class="article-date">
  <time datetime="2017-11-01T09:17:36.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blogs/categories/kotlin/">kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/01/kotlin入门_属性和属性委托/">kotlin入门-属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="属性的懒加载"><a href="#属性的懒加载" class="headerlink" title="属性的懒加载"></a>属性的懒加载</h2><p>这里会讲到三种属性初始化方式</p>
<pre><code>- 延迟属性（lazy properties）: 其值只在首次访问时计算；
- 可观察属性（observable properties）: 监听器会收到有关此属性变更的通知；
- 把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。
</code></pre><p>kotlin为了支持上述特征，实现了<strong>委托属性</strong><br>基本语法是：<property>:<type> by <delegate>.  property 的get和set方法就可以委托给Delete的getValue和setValue方法。第一次访问prperty时，就会调用Delete的getValue方法。Delete 实现的getValue和setValue形式如下：</delegate></type></property></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Delegate &#123;</span><br><span class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</span><br><span class="line">        return &quot;$thisRef, thank you for delegating &apos;$&#123;property.name&#125;&apos; to me!&quot;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</span><br><span class="line">        println(&quot;$value has been assigned to &apos;$&#123;property.name&#125; in $thisRef.&apos;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h2><p>kotlin有几种委托的工厂方法</p>
<h3 id="延迟委托"><a href="#延迟委托" class="headerlink" title="延迟委托"></a>延迟委托</h3><p><strong>lazy()</strong>方法，lazy方法接受一个lambda表达式，并返回实例，第一次调用属性的get()方法会执行lambda表达式，并记录结果，返回。第二次调用属性的get(), 则直接返回。不在计算lambda表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;computed!&quot;)</span><br><span class="line">    &quot;Hello&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(lazyValue)</span><br><span class="line">    println(lazyValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子输出：<br>computed!<br>Hello<br>Hello</p>
<h3 id="可观察属性"><a href="#可观察属性" class="headerlink" title="可观察属性"></a>可观察属性</h3><p>有些属性在修改(set())时，我们希望观察到发生的变化。这里就需要<strong>可观察属性</strong><br><strong>Delegates.observable() </strong>接受两个参数：初始值和修改时处理程序（handler）。 每当我们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值和新值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    var name: String by Delegates.observable(&quot;&lt;no name&gt;&quot;) &#123;</span><br><span class="line">        prop, old, new -&gt;</span><br><span class="line">        println(&quot;$old -&gt; $new&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User()</span><br><span class="line">    user.name = &quot;first&quot;</span><br><span class="line">    user.name = &quot;second&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子输出：</p>
<p><no name=""> -&gt; first<br>first -&gt; second</no></p>
<h3 id="属性放在映射中"><a href="#属性放在映射中" class="headerlink" title="属性放在映射中"></a>属性放在映射中</h3><p>一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他“动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(map: Map&lt;String, Any&gt;) &#123;</span><br><span class="line">	val name: String by map</span><br><span class="line">	val age: Int by map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数接受一个映射map，类体中定义的属性name，age都映射到map中。</p>
<p>我们构造User对象，传一个map：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val user = User(mapOf(</span><br><span class="line">    &quot;name&quot; to &quot;John Doe&quot;,</span><br><span class="line">    &quot;age&quot;  to 25</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(user.name) // Prints &quot;John Doe&quot;</span><br><span class="line">println(user.age) println(user.age)  // Prints 25</span><br></pre></td></tr></table></figure>
<h2 id="局部委托属性（自-1-1-起）"><a href="#局部委托属性（自-1-1-起）" class="headerlink" title="局部委托属性（自 1.1 起）"></a>局部委托属性（自 1.1 起）</h2><p>我们还可以把局部变量声明为委托属性， 达到懒初始化的目的，例如下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun example(computeFoo: () -&gt; Foo) &#123;</span><br><span class="line">    val memoizedFoo by lazy(computeFoo)</span><br><span class="line"></span><br><span class="line">    if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;</span><br><span class="line">        memoizedFoo.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有第一次访问memoizedFoo，才会初始化，当<strong>someCondition</strong>为假时，memoizedFoo根本不会初始化。这样就节省了部分运算。</p>
<h2 id="委托的要求"><a href="#委托的要求" class="headerlink" title="委托的要求"></a>委托的要求</h2><p>这里我们总结了委托对象的要求。<br>对于一个只读属性（即 val 声明的），委托必须提供一个名为 getValue 的函数，该函数接受以下参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型；</span><br><span class="line">property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。</span><br></pre></td></tr></table></figure></p>
<p>这个函数必须返回与属性相同的类型（或其子类型）。<br>对于一个可变属性（即 var 声明的），委托必须额外提供一个名为 setValue 的函数，该函数接受以下参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thisRef —— 同 getValue()；</span><br><span class="line">property —— 同 getValue()；</span><br><span class="line">new value —— 必须和属性同类型或者是它的超类型。</span><br></pre></td></tr></table></figure></p>
<p>getValue() 或/和 setValue() 函数可以通过委托类的成员函数提供或者由扩展函数提供。 当你需要委托属性到原本未提供的这些函数的对象时后者会更便利。 两函数都需要用 operator 关键字来进行标记。<br>委托类可以实现包含所需 operator 方法的 ReadOnlyProperty 或 ReadWriteProperty 接口之一。 这俩接口是在 Kotlin 标准库中声明的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ReadOnlyProperty&lt;in R, out T&gt; &#123;</span><br><span class="line">    operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ReadWriteProperty&lt;in R, T&gt; &#123;</span><br><span class="line">    operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T</span><br><span class="line">    operator fun setValue(thisRef: R, property: KProperty&lt;*&gt;, value: T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/01/kotlin入门_属性和属性委托/" data-id="cjh694n6t000pe0qeqev0hvtx" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门_类与继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/01/kotlin入门_类与继承/" class="article-date">
  <time datetime="2017-11-01T09:16:36.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blogs/categories/kotlin/">kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/01/kotlin入门_类与继承/">类与继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Kotlin 中使用关键字 class 声明类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Invoice &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类声明由<em>类名、类头（指定其类型参数、主构造函数等）和由大括号包围的类体</em>构成。<br>类头和类体都是<em>可选</em>的； 如果一个类没有类体，可以省略花括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Empty</span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在 Kotlin 中的一个类可以有一个<em>主构造函数</em>和<em>一个或多个次构造函数</em>。主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(firstName: String) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Person(firstName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>主构造函数不能包含任何的代码</strong>。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Customer(name: String) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">    		name = 3</span><br><span class="line">        logger.info(&quot;Customer initialized with value $&#123;name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<strong>主构造的参数可以在初始化块中使用</strong>。它们也可以在类体内声明的属性初始化器中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Customer(name: String) &#123;</span><br><span class="line">    val customerKey = name.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(val firstName: String, val lastName: String, var age: Int) &#123;</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。<br>如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Customer public @Inject constructor(name: String) &#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>更多详情，参见 <a href="https://www.kotlincn.net/docs/reference/visibility-modifiers.html#构造函数" target="_blank" rel="noopener">可见性修饰符</a></p>
<h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>类也可以声明前缀有 constructor的次构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(parent: Person) &#123;</span><br><span class="line">        parent.children.add(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(val name: String) &#123;</span><br><span class="line">    constructor(name: String, gender: Boolean) : this(name) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    constructor(name: String, age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class DontCreateMe private constructor () &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Customer(val customerName: String = &quot;&quot;)</span><br></pre></td></tr></table></figure>
<p>创建类的实例<br>要创建一个类的实例，我们就像普通函数一样调用构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val invoice = Invoice()</span><br><span class="line"></span><br><span class="line">val customer = Customer(&quot;Joe Smith&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>注意 Kotlin 并没有 new 关键字。</strong></p>
<p>创建嵌套类、内部类和匿名内部类的类实例在嵌套类中有述。<br>类成员<br>类可以包含：<br>        构造函数和初始化块<br>        函数<br>        属性<br>        嵌套类和内部类<br>        对象声明</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 Kotlin 中所有类都有一个共同的超类 <strong>Any</strong>，这对于没有超类型声明的类是默认超类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Example // 从 Any 隐式继承</span><br></pre></td></tr></table></figure>
<p>Any 不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。 更多细节请查阅Java互操作性部分。<br>要声明一个显式的超类型，我们把类型放到类头的冒号之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open class Base(p: Int) `</span><br><span class="line">class Derived(p: Int) : Base(p)</span><br></pre></td></tr></table></figure>
<p>如果该类有一个主构造函数，其基类型可以（并且必须） 用（基类型的）主构造函数参数就地初始化。<br>如果类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyView : View &#123;</span><br><span class="line">    constructor(ctx: Context) : super(ctx)</span><br><span class="line"></span><br><span class="line">    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类上的 open 标注与 Java 中 final 相反，它允许其他类从这个类继承。<br><strong>默认情况下，在 Kotlin 中所有的类都是 final</strong>， 对应于 Effective Java书中的第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承。</p>
<h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>我们之前提到过，Kotlin 力求清晰显式。与 Java 不同，Kotlin 需要显式标注可覆盖的成员（我们称之为开放）和覆盖后的成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class Base &#123;</span><br><span class="line">    open fun v() &#123;&#125;</span><br><span class="line">    fun nv() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived() : Base() &#123;</span><br><span class="line">    override fun v() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Derived.v() 函数上必须加上 override标注。如果没写，编译器将会报错。 如果函数没有标注 open 如 Base.nv()，则子类中不允许定义相同签名的函数， 不论加不加 override。在一个 final 类中（没有用 open 标注的类），开放成员是禁止的。<br>标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class AnotherDerived() : Base() &#123;</span><br><span class="line">    final override fun v() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h2><p>属性覆盖与方法覆盖类似；<strong>在超类中声明然后在派生类中重新声明的属性必须以 override 开头，并且它们必须具有兼容的类型。每个声明的属性可以由具有初始化器的属性或者具有 getter 方法的属性覆盖。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class Foo &#123;</span><br><span class="line">    open val x: Int get() &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar1 : Foo() &#123;</span><br><span class="line">    override val x: Int = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。 </p>
<p>请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">    val count: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar1(override val count: Int) : Foo</span><br><span class="line"></span><br><span class="line">class Bar2 : Foo &#123;</span><br><span class="line">    override var count: Int = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用超类实现"><a href="#调用超类实现" class="headerlink" title="调用超类实现"></a>调用超类实现</h2><p>派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">open class Foo &#123;</span><br><span class="line">    open fun f() &#123; println(&quot;Foo.f()&quot;) &#125;</span><br><span class="line">    open val x: Int get() = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar : Foo() &#123;</span><br><span class="line">    override fun f() &#123; </span><br><span class="line">        super.f()</span><br><span class="line">        println(&quot;Bar.f()&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override val x: Int get() = super.x + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实现：super@Outer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Bar : Foo() &#123;</span><br><span class="line">    override fun f() &#123; /* …… */ &#125;</span><br><span class="line">    override val x: Int get() = 0</span><br><span class="line">    </span><br><span class="line">    inner class Baz &#123;</span><br><span class="line">        fun g() &#123;</span><br><span class="line">            super@Bar.f() // 调用 Foo 实现的 f()</span><br><span class="line">            println(super@Bar.x) // 使用 Foo 实现的 x 的 getter</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h2><p>在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super<base>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;</span><br><span class="line">    fun f() &#123; print(&quot;A&quot;) &#125;</span><br><span class="line">    fun a() &#123; print(&quot;a&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B &#123;</span><br><span class="line">    fun f() &#123; print(&quot;B&quot;) &#125; // 接口成员默认就是“open”的</span><br><span class="line">    fun b() &#123; print(&quot;b&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C() : A(), B &#123;</span><br><span class="line">    // 编译器要求覆盖 f()：</span><br><span class="line">    override fun f() &#123;</span><br><span class="line">        </span><br><span class="line">        super&lt;A&gt;.f() // 调用 A.f()</span><br><span class="line">        super&lt;B&gt;.f() // 调用 B.f()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时继承 A 和 B 没问题，并且 a() 和 b() 也没问题因为 C 只继承了每个函数的一个实现。 但是 f() 由 C继承了两个实现，所以我们必须在 C 中覆盖 f() 并且提供我们自己的实现来消除歧义。<br>抽象类<br>类和其中的某些成员可以声明为 abstract。 抽象成员在本类中可以不用实现。 <strong>需要注意的是，我们并不需要用 open 标注一个抽象类或者函数</strong>——因为这不言而喻。<br>我们可以用一个抽象成员覆盖一个非抽象的开放成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class Base &#123;</span><br><span class="line">    open fun f() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Derived : Base() &#123;</span><br><span class="line">    override abstract fun f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伴生对象-–-java中的静态类"><a href="#伴生对象-–-java中的静态类" class="headerlink" title="伴生对象 – (java中的静态类)"></a>伴生对象 – (java中的静态类)</h2><p>与 Java 或 C# 不同，在 Kotlin 中类没有静态方法。在大多数情况下，它建议简单地使用包级函数。<br>如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。<br>更具体地讲，如果在你的类内声明了一个伴生对象， 你就可以使用像在 Java/C# 中调用静态方法相同的语法来调用其成员，只使用类名作为限定符。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    fun bark()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Food&#123;</span><br><span class="line">    fun eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Delegate(animal: Animal, food: Food) : Animal by animal, Food by food &#123;</span><br><span class="line">    override fun eat() &#123;</span><br><span class="line">        println(&quot;mouse&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun bark() &#123;</span><br><span class="line">        println(&quot;Miao&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伪多继承的实现-–-接口的代理实现"><a href="#伪多继承的实现-–-接口的代理实现" class="headerlink" title="伪多继承的实现 – 接口的代理实现"></a>伪多继承的实现 – 接口的代理实现</h2><p>Kotlin的动态代理更多的是用在一种需要多继承的场景。<br>例如，还是之前我举的我朋友那个项目的例子，他们的问题在于，每个BaseActivity的子类，都会要请求不同的网络，可能A需要获取用户信息，B需要获取活动列表，C既需要活动列表也需要获取用户信息，D却只需要获取图片列表。</p>
<p>这样一个场景，使用一个代理类实现所有需要获取信息的接口方法。然后让不同的子类去实现所需的接口，请求统一交给代理类完成。这样不仅维护网络请求信息方便，而且每个类不会有额外多出来的方法防止新人接触项目的时候调用错请求方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    fun bark()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Food&#123;</span><br><span class="line">    fun eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Delegate : Animal, Food &#123;</span><br><span class="line">    override fun eat() &#123;</span><br><span class="line">        println(&quot;mouse&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun bark() &#123;</span><br><span class="line">        println(&quot;Miao&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat(animal: Animal, food: Food) : Animal by animal, Food by food &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@JvmStatic fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val delegate: Delegate = Delegate()</span><br><span class="line"></span><br><span class="line">    Cat(delegate, delegate).bark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/01/kotlin入门_类与继承/" data-id="cjh694n71000xe0qevwo9iine" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/类与继承/">类与继承</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin入门_抽象类和接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blogs/2017/11/01/kotlin入门_抽象类和接口/" class="article-date">
  <time datetime="2017-11-01T09:16:36.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blogs/categories/kotlin/">kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blogs/2017/11/01/kotlin入门_抽象类和接口/">kotlin入门_抽象类和接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>抽象方法用<code>absract</code>修饰，只有声明，没有实现，形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract fun methodOk()</span><br></pre></td></tr></table></figure>
<p>抽象方法有如下特点：</p>
<ol>
<li>抽象方法必须用abstract关键字进行修饰</li>
<li>抽象方法不用手动添加open，默认被open修饰</li>
<li>抽象方法没有具体的实现</li>
<li>含有抽象方法的类成为抽象类，必须由abtract关键字修饰</li>
</ol>
<h2 id="抽象属性"><a href="#抽象属性" class="headerlink" title="抽象属性"></a>抽象属性</h2><p>抽象属性就是在var或val前被abstract修饰，抽象属性的声明格式为：</p>
<ol>
<li>抽象属性在抽象类中不能被初始化</li>
<li>在子类没有主构造函数，要对抽象属性，手动初始化。如果子类中有主构造函数，抽象属性可以在主构造函数中声明</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract var addr : String</span><br><span class="line">abstract val weight : Float</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var y: String = &quot;hello&quot;</span><br><span class="line">     get() =  y + &quot;,yes&quot; // error , 正确用法：field + &quot;, yes&quot;</span><br><span class="line">     set(value) &#123;</span><br><span class="line">	     field = value</span><br><span class="line">	  &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 抽象类</span><br><span class="line"></span><br><span class="line">含有**抽象属性**或者**抽象方法**的类，称之为抽象类。抽象类必须用abstract修饰。</span><br><span class="line">实例:</span><br></pre></td></tr></table></figure>
<p>abstract class Person {<br>    abstract val gender: String = “female”<br>    abstract fun haha()<br>    fun eat() {<br>            println(“eat some thing”)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">抽象类特点如下：</span><br><span class="line"></span><br><span class="line">1. 抽象方法必须为`public或者protected`（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；</span><br><span class="line">2.	抽象类不能用来创建对象；</span><br><span class="line">3.	如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。如果抽象类中含有抽象属性，再实现子类中必须将抽象属性初始化，除非子类也为抽象类。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 接口</span><br><span class="line"></span><br><span class="line">接口和抽象类不同的是，**接口不能保存状态，可以有属性但必须是抽象的**。</span><br><span class="line">接口是通过关键字 interface 来定义的：</span><br></pre></td></tr></table></figure></p>
<p>interface MyInterface {<br>    val func : Int<br>    fun bar()<br>    fun foo() {<br>    //函数体是可选的<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 接口中的属性</span><br><span class="line"></span><br><span class="line">接口也可以有属性，但因为接口不能保存状态，所以属性必须是无状态的。</span><br></pre></td></tr></table></figure>
<p>interface A {<br>    val x: String<br>    fun foo()<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 重写多个接口的冲突</span><br></pre></td></tr></table></figure></p>
<pre><code>interdace A {      fun foo() { print(“A”) }      fun bar()  }
interface B {
   fun foo() { print(&quot;B&quot;) }
   fun bar() { print(&quot;bar&quot;) }
} 

class C : A {
    override fun bar() { print(&quot;bar&quot;) }
}

class D : A, B {
    override fun foo() {
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }

    override fun bar() {
        super.bar()
    }
} 
</code></pre><p>```</p>
<p>我们要在类D中分别调用接口A和B的foo方法，可以用语法<code>super&lt;A&gt;.foo()， super&lt;B&gt;.foo()</code>的形式调用。但是在bar()方法中，调用父类bar方法，没有冲突，就可以直接使用<code>super.foo()</code>形式调用。</p>
<h2 id="抽象类和接口的差异"><a href="#抽象类和接口的差异" class="headerlink" title="抽象类和接口的差异"></a>抽象类和接口的差异</h2><h3 id="语法层面上的区别"><a href="#语法层面上的区别" class="headerlink" title="语法层面上的区别"></a>语法层面上的区别</h3><ol>
<li>接口不能保存状态，可以有属性但必须是抽象的，而抽类型可以有属性。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
<h3 id="设计上的区别"><a href="#设计上的区别" class="headerlink" title="设计上的区别"></a>设计上的区别</h3><p>接口和抽象类，一个被子类实现，一个被子类继承，子类都要实现他们的抽象方法，覆盖抽象属性；但表达的现实关系不一样。例如一个鸡，和一个蜻蜓，他们都会飞，他们属于不同类型，那么我们会定义一个Fly的接口，鸡和蜻蜓实现fly接口；但他们都是动物，这里，可以定义Animal抽象类，动物也具有一些普遍特性，比如有血有肉，比如都会吃东西。那就可以用属性和方法实现这些。</p>
<p>接口，描述的是对象<em>“有没有”</em>的关系。抽象类，描述的是对象<em>”是不是“</em>的关系。是二者在设计上的区别。</p>
<p>参考：<br><a href="http://blog.csdn.net/io_field/article/details/52860971" target="_blank" rel="noopener">kotlin抽象类和接口</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/01/kotlin入门_抽象类和接口/" data-id="cjh694n6w000re0qeaomlup7x" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blogs/">&laquo; zurück</a><a class="page-number" href="/blogs/">1</a><span class="page-number current">2</span><a class="page-number" href="/blogs/page/3/">3</a><a class="page-number" href="/blogs/page/4/">4</a><a class="extend next" rel="next" href="/blogs/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blogs/categories/kotlin/">kotlin</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/DSL/">DSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/computer-science/">computer science</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/gitpages使用指南/">gitpages使用指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/java异常/">java异常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/kotlin/">kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/kotlin-入门视频笔记-java和kotlin共存/">kotlin 入门视频笔记 java和kotlin共存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/kotlin资源/">kotlin资源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/lambda表达式/">lambda表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/tapout/">tapout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/unity3d/">unity3d</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/偏函数-partial-function/">偏函数 (partial function)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/健身/">健身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/动画状态机/">动画状态机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/反射/">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/复合函数/">复合函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/生活小事/">生活小事</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/类与继承/">类与继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/评论/">评论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/食物识别/">食物识别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blogs/tags/高阶函数/">高阶函数</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blogs/tags/DSL/" style="font-size: 10px;">DSL</a> <a href="/blogs/tags/computer-science/" style="font-size: 10px;">computer science</a> <a href="/blogs/tags/gitpages使用指南/" style="font-size: 10px;">gitpages使用指南</a> <a href="/blogs/tags/html/" style="font-size: 10px;">html</a> <a href="/blogs/tags/java异常/" style="font-size: 10px;">java异常</a> <a href="/blogs/tags/kotlin/" style="font-size: 20px;">kotlin</a> <a href="/blogs/tags/kotlin-入门视频笔记-java和kotlin共存/" style="font-size: 10px;">kotlin 入门视频笔记 java和kotlin共存</a> <a href="/blogs/tags/kotlin资源/" style="font-size: 10px;">kotlin资源</a> <a href="/blogs/tags/lambda表达式/" style="font-size: 10px;">lambda表达式</a> <a href="/blogs/tags/tapout/" style="font-size: 10px;">tapout</a> <a href="/blogs/tags/unity3d/" style="font-size: 10px;">unity3d</a> <a href="/blogs/tags/偏函数-partial-function/" style="font-size: 10px;">偏函数 (partial function)</a> <a href="/blogs/tags/健身/" style="font-size: 10px;">健身</a> <a href="/blogs/tags/动画状态机/" style="font-size: 10px;">动画状态机</a> <a href="/blogs/tags/反射/" style="font-size: 10px;">反射</a> <a href="/blogs/tags/复合函数/" style="font-size: 10px;">复合函数</a> <a href="/blogs/tags/生活小事/" style="font-size: 10px;">生活小事</a> <a href="/blogs/tags/类与继承/" style="font-size: 10px;">类与继承</a> <a href="/blogs/tags/评论/" style="font-size: 10px;">评论</a> <a href="/blogs/tags/食物识别/" style="font-size: 10px;">食物识别</a> <a href="/blogs/tags/高阶函数/" style="font-size: 10px;">高阶函数</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blogs/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blogs/2018/03/26/遗憾的婚礼见证人/">遗憾的婚礼见证人</a>
          </li>
        
          <li>
            <a href="/blogs/2018/03/01/电子货币投资记录/">(no title)</a>
          </li>
        
          <li>
            <a href="/blogs/2018/01/25/u3d动画状态机/">u3d动画状态机</a>
          </li>
        
          <li>
            <a href="/blogs/2017/12/06/kotlin听课笔记/">kotlin入门视频听课笔记</a>
          </li>
        
          <li>
            <a href="/blogs/2017/12/03/计算机专业的变化/">计算机专业的变化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 tom<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blogs/" class="mobile-nav-link">Home</a>
  
    <a href="/blogs/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blogs/fancybox/jquery.fancybox.css">
  <script src="/blogs/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blogs/js/script.js"></script>



  </div>
</body>
</html>